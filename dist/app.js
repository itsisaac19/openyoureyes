/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/animate.js/dist/scripts/animate.min.js":
/*!*************************************************************!*\
  !*** ./node_modules/animate.js/dist/scripts/animate.min.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/*! animate.js v2.0.2 | (c) 2019-10-24 Josh Johnson | https://github.com/jshjohnson/Animate#readme */\n!function(t,e){ true?module.exports=e():0}(this,function(){\"use strict\";function m(t){var e=typeof t;return null!=t&&(\"object\"==e||\"function\"==e)}var t=\"object\"==typeof __webpack_require__.g&&__webpack_require__.g&&__webpack_require__.g.Object===Object&&__webpack_require__.g,e=\"object\"==typeof self&&self&&self.Object===Object&&self,n=t||e||Function(\"return this\")(),_=function(){return n.Date.now()},r=n.Symbol,o=Object.prototype,i=o.hasOwnProperty,a=o.toString,s=r?r.toStringTag:void 0;var u=Object.prototype.toString;var c=\"[object Null]\",l=\"[object Undefined]\",f=r?r.toStringTag:void 0;function h(t){return null==t?void 0===t?l:c:f&&f in Object(t)?function(t){var e=i.call(t,s),n=t[s];try{var r=!(t[s]=void 0)}catch(t){}var o=a.call(t);return r&&(e?t[s]=n:delete t[s]),o}(t):function(t){return u.call(t)}(t)}function y(t){return null!=t&&\"object\"==typeof t}var p=\"[object Symbol]\";var d=NaN,v=/^\\s+|\\s+$/g,b=/^[-+]0x[0-9a-f]+$/i,g=/^0b[01]+$/i,j=/^0o[0-7]+$/i,O=parseInt;function A(t){if(\"number\"==typeof t)return t;if(function(t){return\"symbol\"==typeof t||y(t)&&h(t)==p}(t))return d;if(m(t)){var e=\"function\"==typeof t.valueOf?t.valueOf():t;t=m(e)?e+\"\":e}if(\"string\"!=typeof t)return 0===t?t:+t;t=t.replace(v,\"\");var n=g.test(t);return n||j.test(t)?O(t.slice(2),n?2:8):b.test(t)?d:+t}var w=\"Expected a function\",E=Math.max,z=Math.min;function x(r,n,t){var o,i,a,s,u,c,l=0,f=!1,p=!1,e=!0;if(\"function\"!=typeof r)throw new TypeError(w);function d(t){var e=o,n=i;return o=i=void 0,l=t,s=r.apply(n,e)}function v(t){var e=t-c;return void 0===c||n<=e||e<0||p&&a<=t-l}function h(){var t=_();if(v(t))return y(t);u=setTimeout(h,function(t){var e=n-(t-c);return p?z(e,a-(t-l)):e}(t))}function y(t){return u=void 0,e&&o?d(t):(o=i=void 0,s)}function b(){var t=_(),e=v(t);if(o=arguments,i=this,c=t,e){if(void 0===u)return function(t){return l=t,u=setTimeout(h,n),f?d(t):s}(c);if(p)return clearTimeout(u),u=setTimeout(h,n),d(c)}return void 0===u&&(u=setTimeout(h,n)),s}return n=A(n)||0,m(t)&&(f=!!t.leading,a=(p=\"maxWait\"in t)?E(A(t.maxWait)||0,n):a,e=\"trailing\"in t?!!t.trailing:e),b.cancel=function(){void 0!==u&&clearTimeout(u),o=c=i=u=void(l=0)},b.flush=function(){return void 0===u?s:y(_())},b}function L(t,e){return t===e||t!=t&&e!=e}function S(t,e){for(var n=t.length;n--;)if(L(t[n][0],e))return n;return-1}var T=Array.prototype.splice;function k(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}k.prototype.clear=function(){this.__data__=[],this.size=0},k.prototype.delete=function(t){var e=this.__data__,n=S(e,t);return!(n<0)&&(n==e.length-1?e.pop():T.call(e,n,1),--this.size,!0)},k.prototype.get=function(t){var e=this.__data__,n=S(e,t);return n<0?void 0:e[n][1]},k.prototype.has=function(t){return-1<S(this.__data__,t)},k.prototype.set=function(t,e){var n=this.__data__,r=S(n,t);return r<0?(++this.size,n.push([t,e])):n[r][1]=e,this};var F=\"[object AsyncFunction]\",P=\"[object Function]\",I=\"[object GeneratorFunction]\",C=\"[object Proxy]\";function $(t){if(!m(t))return!1;var e=h(t);return e==P||e==I||e==F||e==C}var M,R=n[\"__core-js_shared__\"],B=(M=/[^.]+$/.exec(R&&R.keys&&R.keys.IE_PROTO||\"\"))?\"Symbol(src)_1.\"+M:\"\";var U=Function.prototype.toString;var V=/^\\[object .+?Constructor\\]$/,N=Function.prototype,W=Object.prototype,D=N.toString,q=W.hasOwnProperty,H=RegExp(\"^\"+D.call(q).replace(/[\\\\^$.*+?()[\\]{}|]/g,\"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\");function Y(t){return!(!m(t)||function(t){return!!B&&B in t}(t))&&($(t)?H:V).test(function(t){if(null!=t){try{return U.call(t)}catch(t){}try{return t+\"\"}catch(t){}}return\"\"}(t))}function G(t,e){var n=function(t,e){return null==t?void 0:t[e]}(t,e);return Y(n)?n:void 0}var J=G(n,\"Map\"),K=G(Object,\"create\");var Q=Object.prototype.hasOwnProperty;var X=Object.prototype.hasOwnProperty;function Z(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function tt(t,e){var n=t.__data__;return function(t){var e=typeof t;return\"string\"==e||\"number\"==e||\"symbol\"==e||\"boolean\"==e?\"__proto__\"!==t:null===t}(e)?n[\"string\"==typeof e?\"string\":\"hash\"]:n.map}function et(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}Z.prototype.clear=function(){this.__data__=K?K(null):{},this.size=0},Z.prototype.delete=function(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e},Z.prototype.get=function(t){var e=this.__data__;if(K){var n=e[t];return\"__lodash_hash_undefined__\"===n?void 0:n}return Q.call(e,t)?e[t]:void 0},Z.prototype.has=function(t){var e=this.__data__;return K?void 0!==e[t]:X.call(e,t)},Z.prototype.set=function(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=K&&void 0===e?\"__lodash_hash_undefined__\":e,this},et.prototype.clear=function(){this.size=0,this.__data__={hash:new Z,map:new(J||k),string:new Z}},et.prototype.delete=function(t){var e=tt(this,t).delete(t);return this.size-=e?1:0,e},et.prototype.get=function(t){return tt(this,t).get(t)},et.prototype.has=function(t){return tt(this,t).has(t)},et.prototype.set=function(t,e){var n=tt(this,t),r=n.size;return n.set(t,e),this.size+=n.size==r?0:1,this};function nt(t){var e=this.__data__=new k(t);this.size=e.size}nt.prototype.clear=function(){this.__data__=new k,this.size=0},nt.prototype.delete=function(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n},nt.prototype.get=function(t){return this.__data__.get(t)},nt.prototype.has=function(t){return this.__data__.has(t)},nt.prototype.set=function(t,e){var n=this.__data__;if(n instanceof k){var r=n.__data__;if(!J||r.length<199)return r.push([t,e]),this.size=++n.size,this;n=this.__data__=new et(r)}return n.set(t,e),this.size=n.size,this};var rt=function(){try{var t=G(Object,\"defineProperty\");return t({},\"\",{}),t}catch(t){}}();function ot(t,e,n){\"__proto__\"==e&&rt?rt(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n}function it(t,e,n){(void 0===n||L(t[e],n))&&(void 0!==n||e in t)||ot(t,e,n)}var at,st=function(t,e,n){for(var r=-1,o=Object(t),i=n(t),a=i.length;a--;){var s=i[at?a:++r];if(!1===e(o[s],s,o))break}return t},ut= true&&exports&&!exports.nodeType&&exports,ct=ut&&\"object\"==\"object\"&&module&&!module.nodeType&&module,lt=ct&&ct.exports===ut?n.Buffer:void 0,ft=lt?lt.allocUnsafe:void 0;var pt=n.Uint8Array;function dt(t,e){var n=e?function(t){var e=new t.constructor(t.byteLength);return new pt(e).set(new pt(t)),e}(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)}var vt=Object.create,ht=function(t){if(!m(t))return{};if(vt)return vt(t);yt.prototype=t;var e=new yt;return yt.prototype=void 0,e};function yt(){}var bt,mt,_t=(bt=Object.getPrototypeOf,mt=Object,function(t){return bt(mt(t))}),gt=Object.prototype;function jt(t){var e=t&&t.constructor;return t===(\"function\"==typeof e&&e.prototype||gt)}function Ot(t){return y(t)&&\"[object Arguments]\"==h(t)}var At=Object.prototype,wt=At.hasOwnProperty,Et=At.propertyIsEnumerable,zt=Ot(function(){return arguments}())?Ot:function(t){return y(t)&&wt.call(t,\"callee\")&&!Et.call(t,\"callee\")},xt=Array.isArray,Lt=9007199254740991;function St(t){return\"number\"==typeof t&&-1<t&&t%1==0&&t<=Lt}function Tt(t){return null!=t&&St(t.length)&&!$(t)}var kt= true&&exports&&!exports.nodeType&&exports,Ft=kt&&\"object\"==\"object\"&&module&&!module.nodeType&&module,Pt=Ft&&Ft.exports===kt?n.Buffer:void 0,It=(Pt?Pt.isBuffer:void 0)||function(){return!1},Ct=\"[object Object]\",$t=Function.prototype,Mt=Object.prototype,Rt=$t.toString,Bt=Mt.hasOwnProperty,Ut=Rt.call(Object);var Vt={};Vt[\"[object Float32Array]\"]=Vt[\"[object Float64Array]\"]=Vt[\"[object Int8Array]\"]=Vt[\"[object Int16Array]\"]=Vt[\"[object Int32Array]\"]=Vt[\"[object Uint8Array]\"]=Vt[\"[object Uint8ClampedArray]\"]=Vt[\"[object Uint16Array]\"]=Vt[\"[object Uint32Array]\"]=!0,Vt[\"[object Arguments]\"]=Vt[\"[object Array]\"]=Vt[\"[object ArrayBuffer]\"]=Vt[\"[object Boolean]\"]=Vt[\"[object DataView]\"]=Vt[\"[object Date]\"]=Vt[\"[object Error]\"]=Vt[\"[object Function]\"]=Vt[\"[object Map]\"]=Vt[\"[object Number]\"]=Vt[\"[object Object]\"]=Vt[\"[object RegExp]\"]=Vt[\"[object Set]\"]=Vt[\"[object String]\"]=Vt[\"[object WeakMap]\"]=!1;var Nt,Wt= true&&exports&&!exports.nodeType&&exports,Dt=Wt&&\"object\"==\"object\"&&module&&!module.nodeType&&module,qt=Dt&&Dt.exports===Wt&&t.process,Ht=function(){try{var t=Dt&&Dt.require&&Dt.require(\"util\").types;return t||qt&&qt.binding&&qt.binding(\"util\")}catch(t){}}(),Yt=Ht&&Ht.isTypedArray,Gt=Yt?(Nt=Yt,function(t){return Nt(t)}):function(t){return y(t)&&St(t.length)&&!!Vt[h(t)]};function Jt(t,e){if((\"constructor\"!==e||\"function\"!=typeof t[e])&&\"__proto__\"!=e)return t[e]}var Kt=Object.prototype.hasOwnProperty;var Qt=9007199254740991,Xt=/^(?:0|[1-9]\\d*)$/;function Zt(t,e){var n=typeof t;return!!(e=null==e?Qt:e)&&(\"number\"==n||\"symbol\"!=n&&Xt.test(t))&&-1<t&&t%1==0&&t<e}var te=Object.prototype.hasOwnProperty;function ee(t,e){var n=xt(t),r=!n&&zt(t),o=!n&&!r&&It(t),i=!n&&!r&&!o&&Gt(t),a=n||r||o||i,s=a?function(t,e){for(var n=-1,r=Array(t);++n<t;)r[n]=e(n);return r}(t.length,String):[],u=s.length;for(var c in t)!e&&!te.call(t,c)||a&&(\"length\"==c||o&&(\"offset\"==c||\"parent\"==c)||i&&(\"buffer\"==c||\"byteLength\"==c||\"byteOffset\"==c)||Zt(c,u))||s.push(c);return s}var ne=Object.prototype.hasOwnProperty;function re(t){if(!m(t))return function(t){var e=[];if(null!=t)for(var n in Object(t))e.push(n);return e}(t);var e=jt(t),n=[];for(var r in t)(\"constructor\"!=r||!e&&ne.call(t,r))&&n.push(r);return n}function oe(t){return Tt(t)?ee(t,!0):re(t)}function ie(t){return function(t,e,n,r){var o=!n;n=n||{};for(var i,a,s,u,c=-1,l=e.length;++c<l;){var f=e[c],p=r?r(n[f],t[f],f,n,t):void 0;void 0===p&&(p=t[f]),o?ot(n,f,p):(s=p,void 0,u=(i=n)[a=f],Kt.call(i,a)&&L(u,s)&&(void 0!==s||a in i)||ot(i,a,s))}return n}(t,oe(t))}function ae(t,e,n,r,o,i,a){var s=Jt(t,n),u=Jt(e,n),c=a.get(u);if(c)it(t,n,c);else{var l=i?i(s,u,n+\"\",t,e,a):void 0,f=void 0===l;if(f){var p=xt(u),d=!p&&It(u),v=!p&&!d&&Gt(u);l=u,p||d||v?l=xt(s)?s:function(t){return y(t)&&Tt(t)}(s)?function(t,e){var n=-1,r=t.length;for(e=e||Array(r);++n<r;)e[n]=t[n];return e}(s):d?function(t,e){if(e)return t.slice();var n=t.length,r=ft?ft(n):new t.constructor(n);return t.copy(r),r}(u,!(f=!1)):v?dt(u,!(f=!1)):[]:function(t){if(!y(t)||h(t)!=Ct)return!1;var e=_t(t);if(null===e)return!0;var n=Bt.call(e,\"constructor\")&&e.constructor;return\"function\"==typeof n&&n instanceof n&&Rt.call(n)==Ut}(u)||zt(u)?zt(l=s)?l=ie(s):m(s)&&!$(s)||(l=function(t){return\"function\"!=typeof t.constructor||jt(t)?{}:ht(_t(t))}(u)):f=!1}f&&(a.set(u,l),o(l,u,r,i,a),a.delete(u)),it(t,n,l)}}function se(r,o,i,a,s){r!==o&&st(o,function(t,e){if(s=s||new nt,m(t))ae(r,o,e,i,se,a,s);else{var n=a?a(Jt(r,e),t,e+\"\",r,o,s):void 0;void 0===n&&(n=t),it(r,e,n)}},oe)}function ue(t){return t}var ce=Math.max;var le=rt?function(t,e){return rt(t,\"toString\",{configurable:!0,enumerable:!1,value:function(t){return function(){return t}}(e),writable:!0})}:ue,fe=Date.now;var pe,de,ve,he=(pe=le,ve=de=0,function(){var t=fe(),e=16-(t-ve);if(ve=t,0<e){if(800<=++de)return arguments[0]}else de=0;return pe.apply(void 0,arguments)});function ye(t,e){return he(function(i,a,s){return a=ce(void 0===a?i.length-1:a,0),function(){for(var t=arguments,e=-1,n=ce(t.length-a,0),r=Array(n);++e<n;)r[e]=t[a+e];e=-1;for(var o=Array(a+1);++e<a;)o[e]=t[e];return o[a]=s(r),function(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)}(i,this,o)}}(t,e,ue),t+\"\")}var be,me=(be=function(t,e,n){se(t,e,n)},ye(function(t,e){var n=-1,r=e.length,o=1<r?e[r-1]:void 0,i=2<r?e[2]:void 0;for(o=3<be.length&&\"function\"==typeof o?(r--,o):void 0,i&&function(t,e,n){if(!m(n))return!1;var r=typeof e;return!!(\"number\"==r?Tt(n)&&Zt(e,n.length):\"string\"==r&&e in n)&&L(n[e],t)}(e[0],e[1],i)&&(o=r<3?void 0:o,r=1),t=Object(t);++n<r;){var a=e[n];a&&be(t,a,n,o)}return t}));function _e(t){var e=this;if(this.options=me({target:\"[data-animate]\",animatedClass:\"js-animated\",offset:[.5,.5],delay:0,remove:!0,scrolled:!1,reverse:!1,onLoad:!0,onScroll:!0,onResize:!1,disableFilter:function(){},callbackOnInit:function(){},callbackOnInView:function(){},callbackOnAnimate:function(){}},t||{}),this.elements=Array.from(document.querySelectorAll(this.options.target)),this.initialised=!1,\"string\"==typeof this.options.offset){var n=this.options.offset.split(\",\");this.verticalOffset=parseInt(n[0],10),this.horizontalOffset=parseInt(n[1],10)}else{var r=this.options.offset,o=r[0],i=r[1];this.verticalOffset=o,this.horizontalOffset=i}this.throttledEvent=x(function(){e.render()},15)}return _e.prototype.isAboveScrollPos=function(t){var e=t.getBoundingClientRect(),n=window.scrollY||window.pageYOffset;return e.top+e.height*this.verticalOffset<n},_e.prototype.getElementOffset=function(t){var e=t.getAttribute(\"data-animation-offset\"),n=[this.verticalOffset,this.horizontalOffset];if(e){var r=e.split(\",\");n=1===r.length?[parseFloat(r[0]),parseFloat(r[0])]:[parseFloat(r[0]),parseFloat(r[1])]}return n},_e.prototype.isInView=function(t){var e=t.getBoundingClientRect(),n=window.innerHeight||document.documentElement.clientHeight,r=window.innerWidth||document.documentElement.clientWidth,o=this.getElementOffset(t),i=o[0],a=o[1],s=0<e.bottom-e.height*i,u=e.top+e.height*i<n,c=s&&u,l=0<e.right-e.width*a,f=e.left+e.width*a<r;return c&&l&&f},_e.isVisible=function(t){return\"true\"===t.getAttribute(\"data-visibility\")},_e.hasAnimated=function(t){return\"true\"===t.getAttribute(\"data-animated\")},_e.prototype.addAnimation=function(e){if(!_e.isVisible(e)){_e.doCallback(this.options.callbackOnInView,e);var t=e.getAttribute(\"data-animation-classes\");if(t){e.setAttribute(\"data-visibility\",\"true\");var n=t.split(\" \"),r=parseInt(e.getAttribute(\"data-animation-delay\"),10)||this.options.delay;r&&\"number\"==typeof r&&0!==r?setTimeout(function(){n.forEach(function(t){e.classList.add(t)})},r):n.forEach(function(t){e.classList.add(t)}),this.completeAnimation(e)}else console.error(\"No animation classes were given\")}},_e.prototype.removeAnimation=function(e){var t=e.getAttribute(\"data-animation-classes\");if(t){e.setAttribute(\"data-visibility\",\"false\"),e.removeAttribute(\"data-animated\");var n=t.split(\" \"),r=parseInt(e.getAttribute(\"data-animation-delay\"),10);n.push(this.options.animatedClass),r&&\"number\"==typeof r?setTimeout(function(){n.forEach(function(t){e.classList.remove(t)})},r):n.forEach(function(t){e.classList.remove(t)})}else console.error(\"No animation classes were given\")},_e.doCallback=function(t,e){void 0===e&&(e=null),t&&\"function\"==typeof t?t(e):console.error(\"Callback is not a function\")},_e.prototype.completeAnimation=function(e){var t=this,n=function(){var t,e=document.createElement(\"temp\"),n={animation:\"animationend\",OAnimation:\"oAnimationEnd\",MozAnimation:\"animationend\",WebkitAnimation:\"webkitAnimationEnd\"};for(t in n)if(Object.prototype.hasOwnProperty.call(n,t)&&void 0!==e.style[t])return n[t];return null}();n&&e.addEventListener(n,function(){\"false\"!==e.getAttribute(\"data-animation-remove\")&&t.options.remove&&e.getAttribute(\"data-animation-classes\").split(\" \").forEach(function(t){e.classList.remove(t)}),e.classList.add(t.options.animatedClass),e.setAttribute(\"data-animated\",\"true\"),_e.doCallback(t.options.callbackOnAnimate,e)})},_e.prototype.removeEventListeners=function(){var t=this.options,e=t.onResize,n=t.onScroll;e&&window.removeEventListener(\"resize\",this.throttledEvent,!1),n&&window.removeEventListener(\"scroll\",this.throttledEvent,!1)},_e.prototype.addEventListeners=function(){var t=this,e=this.options,n=e.onLoad,r=e.onResize,o=e.onScroll;n&&(\"loading\"===document.readyState?document.addEventListener(\"DOMContentLoaded\",function(){t.render(!0)}):this.render(!0)),r&&window.addEventListener(\"resize\",this.throttledEvent,!1),o&&window.addEventListener(\"scroll\",this.throttledEvent,!1)},_e.prototype.init=function(){this.initialised=!0,this.addEventListeners(),_e.doCallback(this.options.callbackOnInit)},_e.prototype.kill=function(){this.initialised&&(this.removeEventListeners(),this.options=null,this.initialised=!1)},_e.prototype.render=function(n){var r=this;if(this.initialised){if(this.options.disableFilter&&\"function\"==typeof this.options.disableFilter&&!0===this.options.disableFilter())return;this.elements.forEach(function(t){if(r.isInView(t))r.addAnimation(t);else if(_e.hasAnimated(t))\"false\"!==t.getAttribute(\"data-animation-reverse\")&&r.options.reverse&&r.removeAnimation(t);else if(n){var e=t.getAttribute(\"data-animation-scrolled\");(r.options.scrolled||e)&&r.isAboveScrollPos(t)&&r.addAnimation(t)}})}},_e});\n\n\n//# sourceURL=webpack://openyoureyes/./node_modules/animate.js/dist/scripts/animate.min.js?");

/***/ }),

/***/ "./node_modules/vivus/dist/vivus.js":
/*!******************************************!*\
  !*** ./node_modules/vivus/dist/vivus.js ***!
  \******************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.4.6\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n(function () {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element instanceof window.SVGElement || \n      element instanceof window.SVGGElement ||\n      /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage.\n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n      elements = svg.querySelectorAll(this.TYPES.join(','));\n\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {},\n      x1 = element.x1 || 0,\n      y1 = element.y1 || 0,\n      x2 = element.x2 || 0,\n      y2 = element.y2 || 0;\n\n  newElement.d = 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n      x      = parseFloat(element.x)      || 0,\n      y      = parseFloat(element.y)      || 0,\n      width  = parseFloat(element.width)  || 0,\n      height = parseFloat(element.height) || 0;\n\n  if (element.rx || element.ry) {\n    var rx = parseInt(element.rx, 10) || -1,\n        ry = parseInt(element.ry, 10) || -1;\n    rx = Math.min(Math.max(rx < 0 ? ry : rx, 0), width/2);\n    ry = Math.min(Math.max(ry < 0 ? rx : ry, 0), height/2);\n\n    newElement.d = 'M ' + (x + rx) + ',' + y + ' ' +\n                   'L ' + (x + width - rx) + ',' + y + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width) + ',' + (y + ry) + ' ' +\n                   'L ' + (x + width) + ',' + (y + height - ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width - rx) + ',' + (y + height) + ' ' +\n                   'L ' + (x + rx) + ',' + (y + height) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + x + ',' + (y + height - ry) + ' ' +\n                   'L ' + x + ',' + (y + ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + rx) + ',' + y;\n  }\n  else {\n    newElement.d = 'M' + x + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + (y + height) + ' ' +\n                   'L' + x + ' ' + (y + height) + ' Z';\n  }\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var newElement = {},\n      points = element.points.trim().split(' '),\n      i, path;\n\n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var newElement = {},\n      rx = parseFloat(element.rx) || 0,\n      ry = parseFloat(element.ry) || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - rx,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(rx),\n      endY = cy;\n\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {},\n      r  = parseFloat(element.r)  || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - r,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(r),\n      endY = cy;\n      \n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar setupEnv, requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'sync'|'oneByOne'|'script' (to know if the items must be drawn synchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'sync'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus(element, options, callback) {\n  setupEnv();\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n **************************************\n *\n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR = function(x) {\n  return x;\n};\nVivus.EASE = function(x) {\n  return -Math.cos(x * Math.PI) / 2 + 0.5;\n};\nVivus.EASE_OUT = function(x) {\n  return 1 - Math.pow(1 - x, 3);\n};\nVivus.EASE_IN = function(x) {\n  return Math.pow(x, 3);\n};\nVivus.EASE_OUT_BOUNCE = function(x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base, 1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI))) + 1;\n  return 1 - rateR + progress * rateR;\n};\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function(element, options) {\n  var onLoad, self;\n\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not related to an existing ID'\n      );\n    }\n  }\n  this.parentEl = element;\n\n  // Load the SVG with XMLHttpRequest and extract the SVG\n  if (options && options.file) {\n    self = this;\n    onLoad = function() {\n      var domSandbox = document.createElement('div');\n      domSandbox.innerHTML = this.responseText;\n\n      var svgTag = domSandbox.querySelector('svg');\n      if (!svgTag) {\n        throw new Error(\n          'Vivus [load]: Cannot find the SVG in the loaded file : ' +\n            options.file\n        );\n      }\n\n      self.el = svgTag;\n      self.el.setAttribute('width', '100%');\n      self.el.setAttribute('height', '100%');\n      self.parentEl.appendChild(self.el);\n      self.isReady = true;\n      self.init();\n      self = null;\n    };\n\n    var oReq = new window.XMLHttpRequest();\n    oReq.addEventListener('load', onLoad);\n    oReq.open('GET', options.file);\n    oReq.send();\n    return;\n  }\n\n  switch (element.constructor) {\n    case window.SVGSVGElement:\n    case window.SVGElement:\n    case window.SVGGElement:\n      this.el = element;\n      this.isReady = true;\n      break;\n\n    case window.HTMLObjectElement:\n      self = this;\n      onLoad = function(e) {\n        if (self.isReady) {\n          return;\n        }\n        self.el =\n          element.contentDocument &&\n          element.contentDocument.querySelector('svg');\n        if (!self.el && e) {\n          throw new Error(\n            'Vivus [constructor]: object loaded does not contain any SVG'\n          );\n        } else if (self.el) {\n          if (element.getAttribute('built-by-vivus')) {\n            self.parentEl.insertBefore(self.el, element);\n            self.parentEl.removeChild(element);\n            self.el.setAttribute('width', '100%');\n            self.el.setAttribute('height', '100%');\n          }\n          self.isReady = true;\n          self.init();\n          self = null;\n        }\n      };\n\n      if (!onLoad()) {\n        element.addEventListener('load', onLoad);\n      }\n      break;\n\n    default:\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)'\n      );\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function(options) {\n  var allowedTypes = [\n    'delayed',\n    'sync',\n    'async',\n    'nsync',\n    'oneByOne',\n    'scenario',\n    'scenario-sync'\n  ];\n  var allowedStarts = ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error(\n      'Vivus [constructor]: \"options\" parameter must be an object'\n    );\n  } else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.type +\n        ' is not an existing animation `type`'\n    );\n  } else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.start +\n        ' is not an existing `start` option'\n    );\n  } else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE =\n    window.navigator.userAgent.indexOf('MSIE') !== -1 ||\n    window.navigator.userAgent.indexOf('Trident/') !== -1 ||\n    window.navigator.userAgent.indexOf('Edge/') !== -1;\n  this.duration = parsePositiveInt(options.duration, 120);\n  this.delay = parsePositiveInt(options.delay, null);\n  this.dashGap = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender')\n    ? !!options.forceRender\n    : this.isIE;\n  this.reverseStack = !!options.reverseStack;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady = options.onReady;\n  this.map = [];\n  this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible')\n    ? !!options.ignoreInvisible\n    : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function(callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error(\n      'Vivus [constructor]: \"callback\" parameter must be a function'\n    );\n  }\n  this.callback = callback || function() {};\n};\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function() {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint, scale, hasNonScale;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n  hasNonScale = false;\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n\n    pathObj = {\n      el: path,\n      length: 0,\n      startAt: 0,\n      duration: 0,\n      isResizeSensitive: false\n    };\n\n    // If vector effect is non-scaling-stroke, the total length won't match the rendered length\n    // so we need to calculate the scale and apply it\n    if (path.getAttribute('vector-effect') === 'non-scaling-stroke') {\n      var rect = path.getBoundingClientRect();\n      var box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.isResizeSensitive = true;\n      hasNonScale = true;\n    } else {\n      scale = 1;\n    }\n    pathObj.length = Math.ceil(path.getTotalLength() * scale);\n\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn(\n          'Vivus [mapping]: cannot retrieve a path element length',\n          path\n        );\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray =\n      pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  // Show a warning for non-scaling elements\n  if (hasNonScale) {\n    console.warn('Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info.');\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  // Reverse stack if asked\n  if (this.reverseStack) {\n    this.map.reverse();\n  }\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n      case 'delayed':\n        pathObj.startAt = this.delayUnit * i;\n        pathObj.duration = this.duration - this.delay;\n        break;\n\n      case 'oneByOne':\n        pathObj.startAt = (lengthMeter / totalLength) * this.duration;\n        pathObj.duration = (pathObj.length / totalLength) * this.duration;\n        break;\n\n      case 'sync':\n      case 'async':\n      case 'nsync':\n        pathObj.startAt = 0;\n        pathObj.duration = this.duration;\n        break;\n\n      case 'scenario-sync':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          timePoint +\n          (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        timePoint =\n          pAttrs['data-async'] !== undefined\n            ? pathObj.startAt\n            : pathObj.startAt + pathObj.duration;\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n\n      case 'scenario':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Public method to re-evaluate line length for non-scaling lines\n * path elements.\n */\nVivus.prototype.recalc = function () {\n  if (this.mustRecalcScale) {\n    return;\n  }\n  this.mustRecalcScale = requestAnimFrame(function () {\n    this.performLineRecalc();\n  }.bind(this));\n}\n\n/**\n * Private method to re-evaluate line length on non-scaling\n * path elements. Then call for a trace to update the SVG. \n */\nVivus.prototype.performLineRecalc = function () {\n  var pathObj, path, rect, box, scale;\n  for (var i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n    if (pathObj.isResizeSensitive) {\n      path = pathObj.el;\n      rect = path.getBoundingClientRect();\n      box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.length = Math.ceil(path.getTotalLength() * scale);\n      path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    }\n  }\n  this.trace();\n  this.mustRecalcScale = null;\n}\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.draw = function() {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function() {\n      self.draw();\n    });\n    return;\n  }\n\n  this.callback(this);\n  if (this.instanceCallback) {\n    this.instanceCallback(this);\n    this.instanceCallback = null;\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function() {\n  var i, progress, path, currentFrame;\n  currentFrame =\n    this.animTimingFunction(this.currentFrame / this.frameLength) *\n    this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n *\n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function(index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n      newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n *\n */\nVivus.prototype.init = function() {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function() {\n  switch (this.start) {\n    case 'manual':\n      return;\n\n    case 'autostart':\n      this.play();\n      break;\n\n    case 'inViewport':\n      var self = this,\n        listener = function() {\n          if (self.isInViewport(self.parentEl, 1)) {\n            self.play();\n            window.removeEventListener('scroll', listener);\n          }\n        };\n      window.addEventListener('scroll', listener);\n      listener();\n      break;\n  }\n};\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function() {\n  return this.currentFrame === 0\n    ? 'start'\n    : this.currentFrame === this.frameLength\n    ? 'end'\n    : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function() {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function() {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n *\n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function(progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function(speed, callback) {\n  this.instanceCallback = null;\n\n  if (speed && typeof speed === 'function') {\n    this.instanceCallback = speed; // first parameter is actually the callback function\n    speed = null;\n  } else if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  // if the first parameter wasn't the callback, check if the seconds was\n  if (callback && typeof callback === 'function' && !this.instanceCallback) {\n    this.instanceCallback = callback;\n  }\n\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.draw();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function() {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function() {\n  this.stop();\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function(el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function(element) {\n  var attr,\n    output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function(el, h) {\n  var scrolled = this.scrollY(),\n    viewed = scrolled + this.getViewportH(),\n    elBCR = el.getBoundingClientRect(),\n    elHeight = elBCR.height,\n    elTop = scrolled + elBCR.top,\n    elBottom = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return elTop + elHeight * h <= viewed && elBottom >= scrolled;\n};\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function() {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  } else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function() {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\nsetupEnv = function() {\n  if (Vivus.prototype.docElem) {\n    return;\n  }\n\n  /**\n   * Alias for document element\n   *\n   * @type {DOMelement}\n   */\n  Vivus.prototype.docElem = window.document.documentElement;\n\n  /**\n   * Alias for `requestAnimationFrame` or\n   * `setTimeout` function for deprecated browsers.\n   *\n   */\n  requestAnimFrame = (function() {\n    return (\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(/* function */ callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      }\n    );\n  })();\n\n  /**\n   * Alias for `cancelAnimationFrame` or\n   * `cancelTimeout` function for deprecated browsers.\n   *\n   */\n  cancelAnimFrame = (function() {\n    return (\n      window.cancelAnimationFrame ||\n      window.webkitCancelAnimationFrame ||\n      window.mozCancelAnimationFrame ||\n      window.oCancelAnimationFrame ||\n      window.msCancelAnimationFrame ||\n      function(id) {\n        return window.clearTimeout(id);\n      }\n    );\n  })();\n};\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function(value, defaultValue) {\n  var output = parseInt(value, 10);\n  return output >= 0 ? output : defaultValue;\n};\n\n\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return Vivus;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}());\n\n\n\n//# sourceURL=webpack://openyoureyes/./node_modules/vivus/dist/vivus.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var animate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! animate.js */ \"./node_modules/animate.js/dist/scripts/animate.min.js\");\n/* harmony import */ var animate_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(animate_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vivus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vivus */ \"./node_modules/vivus/dist/vivus.js\");\n/* harmony import */ var vivus__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vivus__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\nconst semiCircleAnimation = () => {\r\n    const animate = new (animate_js__WEBPACK_IMPORTED_MODULE_0___default())({        \r\n        target: '.semi-circle',\r\n        animatedClass: 'animated',\r\n        offset: [0, 0],\r\n        delay: 0,\r\n        remove: true,\r\n        scrolled: false,\r\n        reverse: true,\r\n        onLoad: false,\r\n        onScroll: true,\r\n        onResize: false,\r\n        disableFilter: false,\r\n        callbackOnInit: function() {},\r\n        callbackOnInView: function(el) {},\r\n        callbackOnAnimate: function(el) {},\r\n    });\r\n    animate.init();\r\n    return animate;\r\n}\r\n\r\nconst drawEye = (callback) => {\r\n    const drawing = new (vivus__WEBPACK_IMPORTED_MODULE_1___default())('eye-svg', {\r\n        duration: 200,\r\n        type: 'delayed'\r\n    }, callback);\r\n}\r\n\r\n\r\nconst replacePath = (svgId) => {\r\n    let paths = document.getElementById(svgId).querySelectorAll('path');\r\n    console.log(paths);\r\n\r\n    for(let i = paths.length; i--; i>=0) {\r\n        let path = paths[i];\r\n\r\n        if (!path.style.fill && !path.style.stroke && path.parentElement.style.opacity) {\r\n            path.style.fill = 'none';\r\n            path.style.stroke = `rgb(0,0,0, ${path.parentElement.style.opacity})`\r\n            console.log('setting default black', path);\r\n        }\r\n    }\r\n}\r\n/* replacePath('my-svg'); */\r\n\r\n\r\nclass TimingManager {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    startLoadingText() {\r\n        let loadTextLeft = document.querySelector('.load-left .load-text');\r\n        let loadTextRight = document.querySelector('.load-right .load-text');\r\n\r\n        loadTextLeft.style.animation = 'flashfade 2s linear 0s infinite forwards';\r\n        loadTextRight.style.animation = 'flashfade 2s linear 0s infinite forwards';\r\n    }\r\n\r\n    drawEye(animate=true) {\r\n        document.getElementById('eye-cover').classList.remove('hide');\r\n        document.getElementById('eye-svg').classList.add('show');\r\n\r\n        if (animate) {\r\n            drawEye(this.introEnd);\r\n            \r\n            setTimeout(() => {\r\n                this.startLoadingText();\r\n            }, 400);\r\n        } else {\r\n            setTimeout(() => {\r\n                this.introEnd();\r\n            }, 400);\r\n        }\r\n    }\r\n\r\n    introEnd() {\r\n        document.body.classList.remove('hide-scrollbar')\r\n        enableScroll();\r\n        semiCircleAnimation();\r\n\r\n        let loadTextLeft = document.querySelector('.load-left .load-text');\r\n        loadTextLeft.onanimationiteration = (e) => {\r\n            console.log(e.target)\r\n            e.target.style.animationIterationCount = 1\r\n\r\n            document.querySelector('.load-left.wait').classList.remove('wait')\r\n        }\r\n \r\n        let loadTextRight = document.querySelector('.load-right .load-text');\r\n        loadTextRight.onanimationiteration = (e) => {\r\n            console.log(e.target)\r\n            e.target.style.animationIterationCount = 1\r\n\r\n            document.querySelector('.load-right.wait').classList.remove('wait')\r\n        }\r\n\r\n        loadTextLeft.style.animationDuration = '0.4s';\r\n        loadTextRight.style.animationDuration = '0.4s';\r\n    }\r\n}   \r\n\r\nconst manager = new TimingManager();\r\nconst skip = false;\r\n\r\n(() => {\r\n    if (window.pageYOffset >= 0) {\r\n        window.scroll({\r\n            top: 0, \r\n            behavior: 'smooth'\r\n        });\r\n    }\r\n\r\n    let text = document.querySelector('.welcome .your');\r\n    text.onanimationstart = (e) => {\r\n        if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || skip == true) {\r\n            setTimeout(() => {\r\n                manager.drawEye(false);\r\n            }, 1000)\r\n            return;\r\n        }\r\n        setTimeout(() => {\r\n            console.log('drawing eye')\r\n            manager.drawEye();\r\n        }, 200)\r\n    }\r\n})();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Scrolling enabling/disabling\r\n\r\n// left: 37, up: 38, right: 39, down: 40,\r\n// spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36\r\nvar keys = {37: 1, 38: 1, 39: 1, 40: 1};\r\n\r\nfunction preventDefault(e) {\r\n  e.preventDefault();\r\n}\r\n\r\nfunction preventDefaultForScrollKeys(e) {\r\n  if (keys[e.keyCode]) {\r\n    preventDefault(e);\r\n    return false;\r\n  }\r\n}\r\n\r\n// modern Chrome requires { passive: false } when adding event\r\nvar supportsPassive = false;\r\ntry {\r\n  window.addEventListener(\"test\", null, Object.defineProperty({}, 'passive', {\r\n    get: function () { supportsPassive = true; } \r\n  }));\r\n} catch(e) {}\r\n\r\nvar wheelOpt = supportsPassive ? { passive: false } : false;\r\nvar wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel';\r\n\r\n// call this to Disable\r\nfunction disableScroll() {\r\n  window.addEventListener('DOMMouseScroll', preventDefault, false); // older FF\r\n  window.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop\r\n  window.addEventListener('touchmove', preventDefault, wheelOpt); // mobile\r\n  window.addEventListener('keydown', preventDefaultForScrollKeys, false);\r\n}\r\nif (skip == false) {\r\n    disableScroll()\r\n}\r\n\r\n// call this to Enable\r\nfunction enableScroll() {\r\n  window.removeEventListener('DOMMouseScroll', preventDefault, false);\r\n  window.removeEventListener(wheelEvent, preventDefault, wheelOpt); \r\n  window.removeEventListener('touchmove', preventDefault, wheelOpt);\r\n  window.removeEventListener('keydown', preventDefaultForScrollKeys, false);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://openyoureyes/./src/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app.js");
/******/ 	
/******/ })()
;